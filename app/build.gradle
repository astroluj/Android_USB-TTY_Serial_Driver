apply plugin: 'com.android.library'
/*apply plugin: 'com.github.dcendents.android-maven'
group = 'com.github.astroluj'*/
apply from: file('publish.gradle')
// https://github.com/mik3y/usb-serial-for-android
android {
    compileSdkVersion 32
    buildToolsVersion '30.0.2'

    //File 불러오기
    def versionPropsFile = file('version.properties')

    def artifactName = "Android_SerialDriver"
    def versionMajor = 0
    def versionMinor = 0
    def versionPatch = 0
    def versionNumber = 0
    def versionBuild = 0

    //File Read 여부 체크
    if (versionPropsFile.canRead()) {
        def versionProps = new Properties()

        versionProps.load(new FileInputStream(versionPropsFile))

        //Release 할대만 VersionCode 및 patch 값을 Count up해 준다.
        def value = 0
        def runTasks = gradle.startParameter.taskNames
        if ('assemble' in runTasks || 'assembleRelease' in runTasks || 'aR' in runTasks) {
            value = 1
        }

        // version info.
        versionMajor = versionProps['VERSION_MAJOR'].toInteger()
        versionMinor = versionProps['VERSION_MINOR'].toInteger()
        versionPatch = versionProps['VERSION_PATCH'].toInteger() + value
        versionNumber = versionProps['VERSION_NUMBER'].toInteger() + value
        //Build 정보는 Debug, Release 상관없이 빌드하면 무조건 Count up
        versionBuild = versionProps['VERSION_BUILD'].toInteger() + 1

        versionProps['VERSION_PATCH'] = versionPatch.toString()
        versionProps['VERSION_BUILD'] = versionBuild.toString()
        versionProps['VERSION_NUMBER'] = versionNumber.toString()

        //update 된 설정값들을 다시 version.properties 파일에 쓰기
        versionProps.store(versionPropsFile.newWriter(), null)

        defaultConfig {
            minSdkVersion 17
            targetSdkVersion 32
            versionCode versionNumber
            versionName "${versionMajor}.${versionMinor}.${versionPatch}_Release"
            archivesBaseName = artifactName
            consumerProguardFiles 'proguard-rules.pro'

            testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
            testInstrumentationRunnerArguments = [                    // Raspi   Windows   LinuxVM   ...
                                                                      'rfc2217_server_host'                 : '192.168.0.100',
                                                                      'rfc2217_server_nonstandard_baudrates': 'true',   // true    false     false
            ]
            // NDK set
            ndk {
                moduleName "libserial_port"
                abiFilters 'armeabi-v7a', 'arm64-v8a'
            }
        }
        android.libraryVariants.all { variant -> variant.outputs.all { output -> outputFileName = "${archivesBaseName}-${android.defaultConfig.versionName}.aar" } }
    } else {
        throw new Exception("Could not read version.properties!")
    }

    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
        }
    }

    // Jni Setting
    sourceSets.main {
        // Android.mk와 Applicaton.mk를 자동 생성하지 않도록 소스 경로를 설정하지 않습니다.
        // JNI Source 경로를 설정하면 안드로이드 스튜디오의 Native Library Build가 진행되고
        // Android.mk와 Application.mk 파일이 자동으로 생성 됩니다..
        jni.srcDirs = [] // This prevents the auto generation of Android.mk
        //Compile된 Native Library가 저장될 경로
        jniLibs.srcDirs 'src/main/jniLibs'
        //또는 jniLibs.srcDir 'src/main/libs'
    }
    task buildNative(type: Exec) {
        Properties properties = new Properties()
        properties.load(project.rootProject.file('local.properties').newDataInputStream())
        def command = properties.getProperty('ndk.dir', null) + "\\ndk-build.cmd"
        commandLine command, '-C', file('src/main/jni').absolutePath, "NDK_LIBS_OUT=../jniLibs"
    }
    task cleanNative(type: Exec, description: 'Clean JNI object files') {
        def ndkDir = project.android.ndkDirectory.absolutePath
        commandLine "$ndkDir/ndk-build.cmd",
                '-C', file('src/main/jni').absolutePath, // Change src/main/jni the relative path to your jni source
                'clean'
    }

    /*clean.dependsOn 'cleanNative'

    tasks.withType(JavaCompile) {
        compileTask -> compileTask.dependsOn buildNative
    }*/

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}

//apply from: 'publishToMavenLocal.gradle'

//apply from: 'coverage.gradle'

dependencies {
    implementation fileTree(dir: "libs", include: ["*.jar"])
    implementation 'androidx.annotation:annotation:1.3.0'
}